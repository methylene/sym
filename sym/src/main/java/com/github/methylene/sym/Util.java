package com.github.methylene.sym;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Stack;
import java.util.TreeSet;

class Util {

  static final Comparator<int[]> COMPARE_2ND = new Comparator<int[]>() {
    public int compare(int[] a, int[] b) {
      return a[1] - b[1];
    }
  };

  static int[][] withIndex(int[] a) {
    int[][] result = new int[a.length][];
    for (int i = 0; i < a.length; i += 1)
      result[i] = new int[] { i, a[i] };
    return result;
  }

  static int indexOf(Object[] a, Object k) {
    for (int i = 0; i < a.length; i += 1)
      if (Objects.equals(a[i], k))
        return i;
    throw new IllegalArgumentException("could not find " + k + " in input");
  }

  static int indexOf(int[] ints, int k) {
    for (int i = 0; i < ints.length; i += 1)
      if (ints[i] == k)
        return i;
    throw new IllegalArgumentException("could not find " + k + " in input");
  }

  static int[] add(int[] a, int k) {
    int[] result = new int[a.length];
    for (int i = 0; i < a.length; i += 1)
      result[i] = a[i] + k;
    return result;
  }

  static int[] pad(int[] unpadded, int targetLength) {
    if (targetLength <= unpadded.length)
      return unpadded;
    int[] result = new int[targetLength];
    System.arraycopy(unpadded, 0, result, 0, unpadded.length);
    for (int i = unpadded.length; i < targetLength; i += 1) {
      result[i] = i;
    }
    return result;
  }

  static void validate(int[] ints) {
    int[] poscnt = new int[ints.length];
    for (int i : ints) {
      if (i < 0 || i >= ints.length)
        throw new IllegalArgumentException("invalid input: " + Arrays.toString(ints));
      if (poscnt[i] != 0)
        throw new IllegalArgumentException("invalid input: " + Arrays.toString(ints) + ", duplicate: " + i);
      poscnt[i] = 1;
    }
  }

  /**
   * @param size      How many random integers we want
   * @param maxFactor Controls the size of random numbers that are produced
   * @return Random array of {@code size} distinct integers between {@code 0} and {@code size * maxFactor}
   */
  static int[] distinctInts(int size, int maxFactor) {
    boolean[] test = new boolean[size * maxFactor];
    int[] result = new int[size];
    for (int i = 0; i < size; i += 1) {
      Integer candidate = (int) (size * maxFactor * Math.random());
      int direction = Math.random() >= 0.5 ? 1 : -1;
      while (test[candidate]) {
        candidate += direction;
        if (candidate == test.length) {
          candidate -= test.length;
        } else if (candidate < 0) {
          candidate += test.length;
        }
      }
      test[candidate] = true;
      result[i] = candidate;
    }
    return result;
  }

  static String[] symbols(int n) {
    String[] r = new String[n];
    String s = "a";
    for (int i = 0; i < n; i += 1) {
      r[i] = s;
      s = nextString(s);
    }
    return r;
  }

  static String nextString(String s) {
    char last = s.charAt(s.length() - 1);
    if (last == 'z') {
      int nflip = 1;
      while (s.length() > nflip && s.charAt(s.length() - 1 - nflip) == 'z')
        nflip += 1;
      if (nflip == s.length()) {
        StringBuilder news = new StringBuilder();
        for (int i = 0; i < nflip; i += 1)
          news.append('a');
        return news.append('a').toString();
      } else {
        StringBuilder news = new StringBuilder(s.substring(0, s.length() - nflip - 1));
        news.append((char) (s.charAt(s.length() - 1 - nflip) + 1));
        for (int i = 0; i < nflip; i += 1)
          news.append('a');
        return news.toString();
      }
    } else {
      return s.substring(0, s.length() - 1) + ((char) (last + 1));
    }
  }

  static class State {
    final int[] prefix;
    final int[] suffix;

    State(int[] prefix, int[] suffix) {
      this.prefix = prefix;
      this.suffix = suffix;
    }
  }

  static List<Permutation> permutations(int n) {
    int[] start = new int[n];
    for (int i = 0; i < n; i += 1) {
      start[i] = i + 1;
    }
    Stack<State> stack = new Stack<State>();
    stack.push(new State(new int[0], start));
    LinkedList<Permutation> result = new LinkedList<Permutation>();
    while (!stack.isEmpty()) {
      State state = stack.pop();
      if (state.suffix.length == 0) {
        result.push(Permutation.perm1(state.prefix));
      } else {
        for (int i = 0; i < state.suffix.length; i += 1) {
          int[] newPrefix = new int[state.prefix.length + 1];
          System.arraycopy(state.prefix, 0, newPrefix, 0, state.prefix.length);
          newPrefix[state.prefix.length] = state.suffix[i];
          int[] newSuffix = new int[state.suffix.length - 1];
          if (i != 0)
            System.arraycopy(state.suffix, 0, newSuffix, 0, i);
          if (i < state.suffix.length - 1)
            System.arraycopy(state.suffix, i + 1, newSuffix, i, state.suffix.length - 1 - i);
          stack.push(new State(newPrefix, newSuffix));
        }
      }
    }
    return result;
  }

  static Iterable<Permutation[]> cartesian(final List<Permutation> a, final List<Permutation> b) {
    return new Iterable<Permutation[]>() {
      @Override public Iterator<Permutation[]> iterator() {
        return new Iterator<Permutation[]>() {
          int idxa = 0;
          int idxb = 0;

          @Override public boolean hasNext() {
            return idxa < a.size();
          }

          @Override public Permutation[] next() {
            Permutation pa = a.get(idxa);
            Permutation pb = b.get(idxb);
            if (b.size() - idxb == 1) {
              idxb = 0;
              idxa += 1;
            } else {
              idxb += 1;
            }
            return new Permutation[] { pa, pb };
          }

          @Override public void remove() {
            throw new IllegalAccessError();
          }
        };
      }
    };
  }

  static List<Permutation> commutator(final List<Permutation> input) {
    LinkedList<Permutation> result = new LinkedList<Permutation>();
    for (Permutation p : distinct(commutatorIterable(input)))
      result.push(p);
    return result;
  }

  static Iterable<Permutation> commutatorIterable(final List<Permutation> input) {
    return new Iterable<Permutation>() {
      @Override public Iterator<Permutation> iterator() {
        List<Permutation> inlist = Arrays.asList(input.toArray(new Permutation[input.size()]));
        final Iterator<Permutation[]> cartesian = cartesian(inlist, inlist).iterator();
        return new Iterator<Permutation>() {
          @Override public boolean hasNext() {
            return cartesian.hasNext();
          }

          @Override public Permutation next() {
            Permutation[] p = cartesian.next();
            return Permutation.prod(p[0].invert(), p[1].invert(), p[0], p[1]);
          }

          @Override public void remove() {
            throw new IllegalAccessError();
          }
        };
      }
    };
  }

  static <E extends Comparable> Iterable<E> distinct(final Iterable<E> input) {
    return new Iterable<E>() {
      @Override public Iterator<E> iterator() {
        final TreeSet<E> set = new TreeSet<E>();
        final Iterator<E> it = input.iterator();
        return new Iterator<E>() {
          E current = null;

          @Override public boolean hasNext() {
            while (it.hasNext()) {
              E candidate = it.next();
              if (set.add(candidate)) {
                current = candidate;
                return true;
              }
            }
            return false;
          }

          @Override public E next() {
            return current;
          }

          @Override public void remove() {
            throw new IllegalAccessError();
          }
        };
      }
    };
  }

  static List<Permutation> center(final List<Permutation> input) {
    LinkedList<Permutation> result = new LinkedList<Permutation>();
    outer:
    for (Permutation a : input) {
      for (Permutation b : input)
        if (!a.comp(b).equals(b.comp(a)))
          continue outer;
      result.push(a);
    }
    return result;
  }

  static boolean isClosed(final List<Permutation> permutations) {
    TreeSet<Permutation> set = new TreeSet<Permutation>();
    for (Permutation p : permutations)
      set.add(p);
    for (Permutation[] p : cartesian(permutations, permutations))
      if (!set.contains(p[0].comp(p[1])) || !set.contains(p[1].comp(p[0])))
        return false;
    return true;
  }

  /**
   * @param maxValue maximum value of all numbers in a and b
   * @param a        an array of non negative integers
   * @param b        an array of non negative integers
   * @return true iff a and b have no common element
   */
  static boolean disjoint(int maxValue, int[] a, int[] b) {
    boolean[] test = new boolean[maxValue];
    for (int i : a)
      test[i] = true;
    for (int i : b)
      if (test[i])
        return false;
    return true;
  }

  static char[] sortedCopy(char[] chars) {
    char[] sorted = Arrays.copyOf(chars, chars.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static double[] sortedCopy(double[] chars) {
    double[] sorted = Arrays.copyOf(chars, chars.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static float[] sortedCopy(float[] chars) {
    float[] sorted = Arrays.copyOf(chars, chars.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static long[] sortedCopy(long[] chars) {
    long[] sorted = Arrays.copyOf(chars, chars.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static byte[] sortedCopy(byte[] chars) {
    byte[] sorted = Arrays.copyOf(chars, chars.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static Comparable[] sortedCopy(Comparable[] input) {
    Comparable[] sorted = Arrays.copyOf(input, input.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static Object[] sortedCopy(Object[] input, Comparator comp) {
    Object[] sorted = Arrays.copyOf(input, input.length);
    Arrays.sort(sorted, comp);
    return sorted;
  }

  static int[] sortedCopy(int[] ints) {
    int[] sorted = Arrays.copyOf(ints, ints.length);
    Arrays.sort(sorted);
    return sorted;
  }

  static int[] duplicateIndexes(int[] input) {
    int max = 0;
    for (int i : input)
      max = Math.max(max, i);
    int[] test = new int[max + 1];
    Arrays.fill(test, -1);
    for (int i = 0; i < input.length; i += 1) {
      if (test[input[i]] == -1) {
        test[input[i]] = i;
      } else {
        return new int[] { test[input[i]], i };
      }
    }
    return new int[0];
  }

  static int[] duplicateIndexes(long[] input) {
    int max = 0;
    for (long i : input)
      max = (int) Math.max(max, i);
    int[] test = new int[max + 1];
    Arrays.fill(test, -1);
    for (int i = 0; i < input.length; i += 1) {
      if (test[(int) input[i]] == -1) {
        test[(int) input[i]] = i;
      } else {
        return new int[] { test[(int) input[i]], i };
      }
    }
    return new int[0];
  }

}
